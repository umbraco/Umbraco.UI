# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## What is this?

Umbraco.UI (UUI) is a web component library built with **Lit** and **TypeScript**. It provides 90+ reusable UI components (`<uui-button>`, `<uui-input>`, `<uui-table>`, etc.) consumed by the Umbraco CMS backoffice via npm packages (`@umbraco-ui/*`).

## Common Commands

```bash
# Install dependencies (also generates per-package tsconfigs via postinstall)
npm install

# Development — starts Storybook on port 6006
npm run storybook

# Build all packages (Turbo handles ordering via dependency graph)
npm run build

# Full clean + build
npm run build:prod

# Run all component tests with coverage (browser-based)
npm run test

# Run Node-based script tests
npm run test:scripts

# Watch mode for tests
npm run test:watch

# Test a single package (use folder name, e.g. "uui-button")
npm run test:coverage-for uui-button

# Lint
npm run lint

# Auto-fix lint + format
npm run format

# Scaffold a new component (interactive prompts)
npm run new-package
```

## Branching Model

- **`main`** — primary development branch, PR target
- **`production`** — published snapshot, serves Storybook at uui.umbraco.com
- **`release/*`** — intermediary releases (RCs)

## Monorepo Structure

This is an npm workspaces monorepo orchestrated by **Turbo** (build) and **Lerna-Lite** (versioning/publishing).

```
packages/
├── uui-base/          # Foundation: mixins, events, types, registration utilities
├── uui-css/           # Design system CSS custom properties
├── uui/               # Bundle package — re-exports all components
├── uui-button/        # Individual component packages (90+)
├── uui-input/
└── ...
```

### Package dependency chain

`uui-css` → `uui-base` → individual components → `uui` (bundle)

Every component depends on `@umbraco-ui/uui-base`. Some depend on sibling components. The `uui` bundle re-exports everything.

### Build orchestration

- **Turbo** builds all packages in parallel, respecting the dependency graph (`dependsOn: ["^build"]`).
- **uui-css** has a checked-in `custom-properties.module.js` cache file that rollup configs import at load time. This means other packages can load their rollup configs without uui-css being built first.
- Per-package **tsconfig.json** files are checked in. The `postinstall` script runs `generate-ts-config.js` to handle newly scaffolded packages.
- **Storybook** imports source CSS (`lib/uui-css.css`) directly via Vite, so it doesn't require uui-css to be built first.

### Custom properties cache (`packages/uui-css/custom-properties.module.js`)

This file is auto-generated during the uui-css build and tracked in git. When CSS custom properties change (files in `packages/uui-css/lib/custom-properties/`), the cache gets regenerated. The updated file should be committed alongside the source changes — same workflow as `package-lock.json`. The file is excluded from prettier via `.prettierignore`.

### Versioning & publishing

- All packages share a **single version number** (lockstep via `forcePublish: true` in `lerna.json`). A release bumps all ~90 packages together.
- **Conventional commits are required** — Lerna uses them to generate changelogs. Format: `type(scope): description`
  - Types: `feat`, `fix`, `build`, `docs`, `test`, `refactor`, `chore`
  - Scope: package name without `uui-` prefix when targeting a specific component (e.g. `fix(combobox): ...`)
  - `feat` triggers a minor version bump, `fix` triggers a patch bump
- Publishing happens from CI on `v*` tags via `lerna publish from-package`.

### Local testing with the backoffice

The backoffice consumes UUI via published npm packages. To test local changes before publishing:

```bash
npm run pack-all          # Build + pack all packages as tarballs
npm run pack-all-no-build # Pack without rebuilding (if already built)
npm run pack              # Pack a single package
```

Install the resulting `.tgz` files in the consuming project.

## Component Architecture

### File structure per package

```
packages/uui-{name}/
├── lib/
│   ├── index.ts                    # Public exports
│   ├── uui-{name}.element.ts      # Component class
│   ├── uui-{name}.test.ts         # Tests
│   └── uui-{name}.story.ts        # Storybook story
├── package.json
├── rollup.config.js                # Imports shared config from packages/rollup-package.config.mjs
└── tsconfig.json                   # Checked in; regenerated by postinstall for new packages
```

### Key patterns

**Mixin composition** — components compose behavior via mixins from `uui-base`:

```typescript
export class UUIButtonElement extends UUIFormControlMixin(
  LabelMixin('', PopoverTargetMixin(LitElement))
) { ... }
```

**Element registration** — use `@defineElement` decorator (not `customElements.define`):

```typescript
import { defineElement } from '@umbraco-ui/uui-base/lib/registration';

@defineElement('uui-button')
export class UUIButtonElement extends ... { }
```

**Events** — custom events extend `UUIEvent` from `uui-base` for type safety.

**CSS custom properties** — components expose styling via `--uui-*` variables.

**Shadow DOM** — all components use shadow DOM for encapsulation.

### Component rules (from CONTRIBUTING.md)

- Element name prefixed with `uui-`, class named `UUI{PascalCase}Element`
- Attribute reflection only for styling, not state
- No external dependencies without HQ approval
- No tag name assumptions — use `:host` or `this`
- JSDoc all properties, slots, events, and CSS custom properties
- Tests must pass, including basic accessibility tests
- Must have a Storybook story

## Build System

- **TypeScript** → `tsc --build` (declaration only) → **Rollup** + esbuild (ES2022 output)
- Shared Rollup config: `packages/rollup-package.config.mjs`
- Turbo handles task orchestration and caching (`turbo.json`)

## Testing

- **Component tests** (`npm test`): Web Test Runner + @open-wc/testing (Mocha + Chai), runs in Chromium, Firefox, WebKit via Playwright. Config: `web-test-runner.config.mjs`. Tests live alongside components: `uui-{name}.test.ts`.
- **Script tests** (`npm run test:scripts`): Node's built-in test runner (`node:test`). Tests live alongside scripts: `scripts/**/*.test.mjs`.
- Accessibility testing via `expect(element).to.be.accessible()`

## Linting & Formatting

- **ESLint** v9 flat config (`eslint.config.mjs`) with `typescript-eslint`, `eslint-plugin-lit`, `eslint-plugin-wc`, Prettier integration
- **Prettier**: single quotes, 2-space indent, `arrowParens: avoid`, `bracketSameLine: true`
- **Pre-commit hook** (Husky + lint-staged): runs ESLint, type-check on `*.element.ts`, Prettier

## Runtime Requirements

- Node >= 24.13, npm >= 11 (see `.nvmrc` and `engines` in package.json)
- Lit ^2.8.0 (pinned)
- Target: ES2022

## Development Philosophy

Behavioral guidelines to reduce common LLM coding mistakes. Merge with project-specific instructions as needed.

**Tradeoff:** These guidelines bias toward caution over speed. For trivial tasks, use judgment.

### 1. Think Before Coding

**Don't assume. Don't hide confusion. Surface tradeoffs.**

Before implementing:

- State your assumptions explicitly. If uncertain, ask.
- If multiple interpretations exist, present them - don't pick silently.
- If a simpler approach exists, say so. Push back when warranted.
- If something is unclear, stop. Name what's confusing. Ask.

### 2. Simplicity First

**Minimum code that solves the problem. Nothing speculative.**

- No features beyond what was asked.
- No abstractions for single-use code.
- No "flexibility" or "configurability" that wasn't requested.
- No error handling for impossible scenarios.
- If you write 200 lines and it could be 50, rewrite it.

Ask yourself: "Would a senior engineer say this is overcomplicated?" If yes, simplify.

### 3. Surgical Changes

**Touch only what you must. Clean up only your own mess.**

When editing existing code:

- Don't "improve" adjacent code, comments, or formatting.
- Don't refactor things that aren't broken.
- Match existing style, even if you'd do it differently.
- If you notice unrelated dead code, mention it - don't delete it.

When your changes create orphans:

- Remove imports/variables/functions that YOUR changes made unused.
- Don't remove pre-existing dead code unless asked.

The test: Every changed line should trace directly to the user's request.

### 4. Goal-Driven Execution

**Define success criteria. Loop until verified.**

Transform tasks into verifiable goals:

- "Add validation" → "Write tests for invalid inputs, then make them pass"
- "Fix the bug" → "Write a test that reproduces it, then make it pass"
- "Refactor X" → "Ensure tests pass before and after"

For multi-step tasks, state a brief plan:

```
1. [Step] → verify: [check]
2. [Step] → verify: [check]
3. [Step] → verify: [check]
```

Strong success criteria let you loop independently. Weak criteria ("make it work") require constant clarification.

---

**These guidelines are working if:** fewer unnecessary changes in diffs, fewer rewrites due to overcomplication, and clarifying questions come before implementation rather than after mistakes.
